{"ast":null,"code":"import { combineReducers, configureStore } from \"@reduxjs/toolkit\";\nimport userReducer from \"./reducers/UserSlice\";\nimport userAsyncThunkReducer from \"./reducers/userAsyncThunkSlice\";\nimport { userAPI } from \"../services/UserService\";\nimport { todoApi } from \"../services/TodoService\";\nimport { albumApi } from \"../services/AlbumService\";\nimport { commentApi } from \"../services/CommentService\";\nimport { photoAPI } from \"../services/PhotoService\";\n\n// Создаём корневой редюсер, состоящий из комбинации всех редюсеров\nconst rootReducer = combineReducers({\n  userReducer,\n  userAsyncThunkReducer,\n  // Регистрируем редюсер с UserService.ts как ключ-значение\n  [userAPI.reducerPath]: userAPI.reducer,\n  [todoApi.reducerPath]: todoApi.reducer,\n  [albumApi.reducerPath]: albumApi.reducer,\n  [commentApi.reducerPath]: commentApi.reducer,\n  [photoAPI.reducerPath]: photoAPI.reducer\n});\n\n// Создаём функцию setupStore, с помощью её мы будем конфигурировать\n// наше редакс-хранилище. Без использования toolkit мы использовали\n// createReducer. Сейчас используем configureStore().\nexport const setupStore = () => {\n  return configureStore({\n    reducer: rootReducer,\n    // Добавляем к дефолтному мидлвееру, методом concat(), мидлвеер из нашего postAPI.\n    // Затем, методом concat(), добавляем мидлвеер из нашего userAPI\n    // Затем, методом concat(), добавляем мидлвеер из нашего todoAPI\n    middleware: getDefaultMiddleware => getDefaultMiddleware().concat(userAPI.middleware).concat(todoApi.middleware).concat(albumApi.middleware).concat(commentApi.middleware).concat(photoAPI.middleware)\n  });\n};\n\n// Три базовых типа, которые нам в дальнейшей работе понадобятся\n// Нам необходимо получить тип нашего состояния\n// Так же получим тип самого стора, с помощью ретюрнтайп\n// Так же получим тип dispatch нашего хранилища. Определив тип диспатча,\n// мы не сможем задиспачить те экшены, которые мы не определили","map":{"version":3,"names":["combineReducers","configureStore","userReducer","userAsyncThunkReducer","userAPI","todoApi","albumApi","commentApi","photoAPI","rootReducer","reducerPath","reducer","setupStore","middleware","getDefaultMiddleware","concat"],"sources":["C:/Projects Ulbi/redux-toolkit-typescript-3/src/store/store.ts"],"sourcesContent":["import { combineReducers, configureStore } from \"@reduxjs/toolkit\";\r\nimport userReducer from \"./reducers/UserSlice\";\r\nimport userAsyncThunkReducer from \"./reducers/userAsyncThunkSlice\";\r\nimport { userAPI } from \"../services/UserService\";\r\nimport { todoApi } from \"../services/TodoService\";\r\nimport { albumApi } from \"../services/AlbumService\";\r\nimport { commentApi } from \"../services/CommentService\";\r\nimport { photoAPI } from \"../services/PhotoService\";\r\n\r\n// Создаём корневой редюсер, состоящий из комбинации всех редюсеров\r\nconst rootReducer = combineReducers({\r\n  userReducer,\r\n  userAsyncThunkReducer,\r\n\r\n  // Регистрируем редюсер с UserService.ts как ключ-значение\r\n  [userAPI.reducerPath]: userAPI.reducer,\r\n  [todoApi.reducerPath]: todoApi.reducer,\r\n  [albumApi.reducerPath]: albumApi.reducer,\r\n  [commentApi.reducerPath]: commentApi.reducer,\r\n  [photoAPI.reducerPath]: photoAPI.reducer,\r\n});\r\n\r\n// Создаём функцию setupStore, с помощью её мы будем конфигурировать\r\n// наше редакс-хранилище. Без использования toolkit мы использовали\r\n// createReducer. Сейчас используем configureStore().\r\nexport const setupStore = () => {\r\n  return configureStore({\r\n    reducer: rootReducer,\r\n\r\n    // Добавляем к дефолтному мидлвееру, методом concat(), мидлвеер из нашего postAPI.\r\n    // Затем, методом concat(), добавляем мидлвеер из нашего userAPI\r\n    // Затем, методом concat(), добавляем мидлвеер из нашего todoAPI\r\n    middleware: (getDefaultMiddleware) =>\r\n      getDefaultMiddleware()\r\n        .concat(userAPI.middleware)\r\n        .concat(todoApi.middleware)\r\n        .concat(albumApi.middleware)\r\n        .concat(commentApi.middleware)\r\n        .concat(photoAPI.middleware),\r\n  });\r\n};\r\n\r\n// Три базовых типа, которые нам в дальнейшей работе понадобятся\r\n// Нам необходимо получить тип нашего состояния\r\nexport type RootState = ReturnType<typeof rootReducer>;\r\n\r\n// Так же получим тип самого стора, с помощью ретюрнтайп\r\nexport type AppStore = ReturnType<typeof setupStore>;\r\n\r\n// Так же получим тип dispatch нашего хранилища. Определив тип диспатча,\r\n// мы не сможем задиспачить те экшены, которые мы не определили\r\nexport type AppDispacth = AppStore[\"dispatch\"];\r\n"],"mappings":"AAAA,SAASA,eAAe,EAAEC,cAAc,QAAQ,kBAAkB;AAClE,OAAOC,WAAW,MAAM,sBAAsB;AAC9C,OAAOC,qBAAqB,MAAM,gCAAgC;AAClE,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,QAAQ,QAAQ,0BAA0B;AACnD,SAASC,UAAU,QAAQ,4BAA4B;AACvD,SAASC,QAAQ,QAAQ,0BAA0B;;AAEnD;AACA,MAAMC,WAAW,GAAGT,eAAe,CAAC;EAClCE,WAAW;EACXC,qBAAqB;EAErB;EACA,CAACC,OAAO,CAACM,WAAW,GAAGN,OAAO,CAACO,OAAO;EACtC,CAACN,OAAO,CAACK,WAAW,GAAGL,OAAO,CAACM,OAAO;EACtC,CAACL,QAAQ,CAACI,WAAW,GAAGJ,QAAQ,CAACK,OAAO;EACxC,CAACJ,UAAU,CAACG,WAAW,GAAGH,UAAU,CAACI,OAAO;EAC5C,CAACH,QAAQ,CAACE,WAAW,GAAGF,QAAQ,CAACG;AACnC,CAAC,CAAC;;AAEF;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAC9B,OAAOX,cAAc,CAAC;IACpBU,OAAO,EAAEF,WAAW;IAEpB;IACA;IACA;IACAI,UAAU,EAAGC,oBAAoB,IAC/BA,oBAAoB,CAAC,CAAC,CACnBC,MAAM,CAACX,OAAO,CAACS,UAAU,CAAC,CAC1BE,MAAM,CAACV,OAAO,CAACQ,UAAU,CAAC,CAC1BE,MAAM,CAACT,QAAQ,CAACO,UAAU,CAAC,CAC3BE,MAAM,CAACR,UAAU,CAACM,UAAU,CAAC,CAC7BE,MAAM,CAACP,QAAQ,CAACK,UAAU;EACjC,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AAGA;AAGA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}