{"ast":null,"code":"import { combineReducers, configureStore } from \"@reduxjs/toolkit\";\nimport userReducer from \"./reducers/UserSlice\";\nimport userAsyncThunkReducer from \"./reducers/userAsyncThunkSlice\";\nimport { userAPI } from \"../services/UserService\";\nimport { todoApi } from \"../services/TodoService\";\nimport { albumApi } from \"../services/AlbumService\";\nimport { commentAPI } from \"../services/CommentService\";\n\n// Создаём корневой редюсер, состоящий из комбинации всех редюсеров\nconst rootReducer = combineReducers({\n  userReducer,\n  userAsyncThunkReducer,\n  // Регистрируем редюсер с UserService.ts как ключ-значение\n  [userAPI.reducerPath]: userAPI.reducer,\n  [todoApi.reducerPath]: todoApi.reducer,\n  [albumApi.reducerPath]: albumApi.reducer,\n  [commentAPI.reducerPath]: commentAPI.reducer\n});\n\n// Создаём функцию setupStore, с помощью её мы будем конфигурировать\n// наше редакс-хранилище. Без использования toolkit мы использовали\n// createReducer. Сейчас используем configureStore().\nexport const setupStore = () => {\n  return configureStore({\n    reducer: rootReducer,\n    // Добавляем к дефолтному мидлвееру, методом concat(), мидлвеер из нашего postAPI.\n    // Затем, методом concat(), добавляем мидлвеер из нашего userAPI\n    // Затем, методом concat(), добавляем мидлвеер из нашего todoAPI\n    middleware: getDefaultMiddleware => getDefaultMiddleware().concat(userAPI.middleware).concat(todoApi.middleware).concat(albumApi.middleware).concat(commentAPI.middleware)\n  });\n};\n\n// Три базовых типа, которые нам в дальнейшей работе понадобятся\n// Нам необходимо получить тип нашего состояния\n// Так же получим тип самого стора, с помощью ретюрнтайп\n// Так же получим тип dispatch нашего хранилища. Определив тип диспатча,\n// мы не сможем задиспачить те экшены, которые мы не определили","map":{"version":3,"names":["combineReducers","configureStore","userReducer","userAsyncThunkReducer","userAPI","todoApi","albumApi","commentAPI","rootReducer","reducerPath","reducer","setupStore","middleware","getDefaultMiddleware","concat"],"sources":["C:/Projects Ulbi/redux-toolkit-typescript-3/src/store/store.ts"],"sourcesContent":["import { combineReducers, configureStore } from \"@reduxjs/toolkit\";\r\nimport userReducer from \"./reducers/UserSlice\";\r\nimport userAsyncThunkReducer from \"./reducers/userAsyncThunkSlice\";\r\nimport { userAPI } from \"../services/UserService\";\r\nimport { todoApi } from \"../services/TodoService\";\r\nimport { albumApi } from \"../services/AlbumService\";\r\nimport { commentAPI } from \"../services/CommentService\";\r\n\r\n// Создаём корневой редюсер, состоящий из комбинации всех редюсеров\r\nconst rootReducer = combineReducers({\r\n  userReducer,\r\n  userAsyncThunkReducer,\r\n\r\n  // Регистрируем редюсер с UserService.ts как ключ-значение\r\n  [userAPI.reducerPath]: userAPI.reducer,\r\n  [todoApi.reducerPath]: todoApi.reducer,\r\n  [albumApi.reducerPath]: albumApi.reducer,\r\n  [commentAPI.reducerPath]: commentAPI.reducer,\r\n});\r\n\r\n// Создаём функцию setupStore, с помощью её мы будем конфигурировать\r\n// наше редакс-хранилище. Без использования toolkit мы использовали\r\n// createReducer. Сейчас используем configureStore().\r\nexport const setupStore = () => {\r\n  return configureStore({\r\n    reducer: rootReducer,\r\n\r\n    // Добавляем к дефолтному мидлвееру, методом concat(), мидлвеер из нашего postAPI.\r\n    // Затем, методом concat(), добавляем мидлвеер из нашего userAPI\r\n    // Затем, методом concat(), добавляем мидлвеер из нашего todoAPI\r\n    middleware: (getDefaultMiddleware) =>\r\n      getDefaultMiddleware()\r\n        .concat(userAPI.middleware)\r\n        .concat(todoApi.middleware)\r\n        .concat(albumApi.middleware)\r\n        .concat(commentAPI.middleware),\r\n  });\r\n};\r\n\r\n// Три базовых типа, которые нам в дальнейшей работе понадобятся\r\n// Нам необходимо получить тип нашего состояния\r\nexport type RootState = ReturnType<typeof rootReducer>;\r\n\r\n// Так же получим тип самого стора, с помощью ретюрнтайп\r\nexport type AppStore = ReturnType<typeof setupStore>;\r\n\r\n// Так же получим тип dispatch нашего хранилища. Определив тип диспатча,\r\n// мы не сможем задиспачить те экшены, которые мы не определили\r\nexport type AppDispacth = AppStore[\"dispatch\"];\r\n"],"mappings":"AAAA,SAASA,eAAe,EAAEC,cAAc,QAAQ,kBAAkB;AAClE,OAAOC,WAAW,MAAM,sBAAsB;AAC9C,OAAOC,qBAAqB,MAAM,gCAAgC;AAClE,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,QAAQ,QAAQ,0BAA0B;AACnD,SAASC,UAAU,QAAQ,4BAA4B;;AAEvD;AACA,MAAMC,WAAW,GAAGR,eAAe,CAAC;EAClCE,WAAW;EACXC,qBAAqB;EAErB;EACA,CAACC,OAAO,CAACK,WAAW,GAAGL,OAAO,CAACM,OAAO;EACtC,CAACL,OAAO,CAACI,WAAW,GAAGJ,OAAO,CAACK,OAAO;EACtC,CAACJ,QAAQ,CAACG,WAAW,GAAGH,QAAQ,CAACI,OAAO;EACxC,CAACH,UAAU,CAACE,WAAW,GAAGF,UAAU,CAACG;AACvC,CAAC,CAAC;;AAEF;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAC9B,OAAOV,cAAc,CAAC;IACpBS,OAAO,EAAEF,WAAW;IAEpB;IACA;IACA;IACAI,UAAU,EAAGC,oBAAoB,IAC/BA,oBAAoB,CAAC,CAAC,CACnBC,MAAM,CAACV,OAAO,CAACQ,UAAU,CAAC,CAC1BE,MAAM,CAACT,OAAO,CAACO,UAAU,CAAC,CAC1BE,MAAM,CAACR,QAAQ,CAACM,UAAU,CAAC,CAC3BE,MAAM,CAACP,UAAU,CAACK,UAAU;EACnC,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AAGA;AAGA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}