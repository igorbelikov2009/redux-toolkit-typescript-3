{"ast":null,"code":"import { combineReducers, configureStore } from \"@reduxjs/toolkit\";\nimport userReducer from \"./reducers/UserSlice\";\nimport userAsyncThunkReducer from \"./reducers/userAsyncThunkSlice\";\nimport { userAPI } from \"../services/UserService\";\nimport { todoApi } from \"../services/TodoService\";\n\n// Создаём корневой редюсер, состоящий из комбинации всех редюсеров\nconst rootReducer = combineReducers({\n  userReducer,\n  userAsyncThunkReducer,\n  // Регистрируем редюсер с UserService.ts как ключ-значение\n  [userAPI.reducerPath]: userAPI.reducer,\n  [todoApi.reducerPath]: todoApi.reducer\n});\n\n// Создаём функцию setupStore, с помощью её мы будем конфигурировать\n// наше редакс-хранилище. Без использования toolkit мы использовали\n// createReducer. Сейчас используем configureStore().\nexport const setupStore = () => {\n  return configureStore({\n    reducer: rootReducer,\n    // Добавляем к дефолтному мидлвееру, методом concat(), мидлвеер из нашего postAPI.\n    // Затем, методом concat(), добавляем мидлвеер из нашего todoAPI\n    // Затем, методом concat(), добавляем мидлвеер из нашего commentAPI\n    middleware: getDefaultMiddleware => getDefaultMiddleware().concat(userAPI.middleware)\n  });\n};\n\n// Три базовых типа, которые нам в дальнейшей работе понадобятся\n// Нам необходимо получить тип нашего состояния\n// Так же получим тип самого стора, с помощью ретюрнтайп\n// Так же получим тип dispatch нашего хранилища. Определив тип диспатча,\n// мы не сможем задиспачить те экшены, которые мы не определили","map":{"version":3,"names":["combineReducers","configureStore","userReducer","userAsyncThunkReducer","userAPI","todoApi","rootReducer","reducerPath","reducer","setupStore","middleware","getDefaultMiddleware","concat"],"sources":["C:/Projects Ulbi/redux-toolkit-typescript-3/src/store/store.ts"],"sourcesContent":["import { combineReducers, configureStore } from \"@reduxjs/toolkit\";\r\nimport userReducer from \"./reducers/UserSlice\";\r\nimport userAsyncThunkReducer from \"./reducers/userAsyncThunkSlice\";\r\nimport { userAPI } from \"../services/UserService\";\r\nimport { todoApi } from \"../services/TodoService\";\r\n\r\n// Создаём корневой редюсер, состоящий из комбинации всех редюсеров\r\nconst rootReducer = combineReducers({\r\n  userReducer,\r\n  userAsyncThunkReducer,\r\n\r\n  // Регистрируем редюсер с UserService.ts как ключ-значение\r\n  [userAPI.reducerPath]: userAPI.reducer,\r\n  [todoApi.reducerPath]: todoApi.reducer,\r\n});\r\n\r\n// Создаём функцию setupStore, с помощью её мы будем конфигурировать\r\n// наше редакс-хранилище. Без использования toolkit мы использовали\r\n// createReducer. Сейчас используем configureStore().\r\nexport const setupStore = () => {\r\n  return configureStore({\r\n    reducer: rootReducer,\r\n\r\n    // Добавляем к дефолтному мидлвееру, методом concat(), мидлвеер из нашего postAPI.\r\n    // Затем, методом concat(), добавляем мидлвеер из нашего todoAPI\r\n    // Затем, методом concat(), добавляем мидлвеер из нашего commentAPI\r\n    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(userAPI.middleware),\r\n  });\r\n};\r\n\r\n// Три базовых типа, которые нам в дальнейшей работе понадобятся\r\n// Нам необходимо получить тип нашего состояния\r\nexport type RootState = ReturnType<typeof rootReducer>;\r\n\r\n// Так же получим тип самого стора, с помощью ретюрнтайп\r\nexport type AppStore = ReturnType<typeof setupStore>;\r\n\r\n// Так же получим тип dispatch нашего хранилища. Определив тип диспатча,\r\n// мы не сможем задиспачить те экшены, которые мы не определили\r\nexport type AppDispacth = AppStore[\"dispatch\"];\r\n"],"mappings":"AAAA,SAASA,eAAe,EAAEC,cAAc,QAAQ,kBAAkB;AAClE,OAAOC,WAAW,MAAM,sBAAsB;AAC9C,OAAOC,qBAAqB,MAAM,gCAAgC;AAClE,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,OAAO,QAAQ,yBAAyB;;AAEjD;AACA,MAAMC,WAAW,GAAGN,eAAe,CAAC;EAClCE,WAAW;EACXC,qBAAqB;EAErB;EACA,CAACC,OAAO,CAACG,WAAW,GAAGH,OAAO,CAACI,OAAO;EACtC,CAACH,OAAO,CAACE,WAAW,GAAGF,OAAO,CAACG;AACjC,CAAC,CAAC;;AAEF;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAC9B,OAAOR,cAAc,CAAC;IACpBO,OAAO,EAAEF,WAAW;IAEpB;IACA;IACA;IACAI,UAAU,EAAGC,oBAAoB,IAAKA,oBAAoB,CAAC,CAAC,CAACC,MAAM,CAACR,OAAO,CAACM,UAAU;EACxF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AAGA;AAGA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}