{"ast":null,"code":"// В редакс редюсер - это просто по сути чистая функция, которая принимает\n// state, action. В зависимости от экшена как-то изменяет state и возвращает\n// его нам в обновлённом виде. В редакс-тулкит есть, так называемые, слайсы.\n// Это некоторая обёртка над редюсерами, которая добовляет дополнительный\n// функционал и упрощает работу.\n\nimport { createSlice } from \"@reduxjs/toolkit\";\n// Создаём объект типа UserState, который ожидаем в качестве загрузки.\nconst initialState = {\n  users: [],\n  isLoading: false,\n  error: \"\",\n  count: 0\n};\n\n// Создаём сам редюсер. Подобные редюсеры в тулкит называются слайсами.\n// Создаются они помощью специальной функции createSlice() и принимают параметрами\n// объект с опциями.\nexport const userSlice = createSlice({\n  name: \"user\",\n  initialState: initialState,\n  // Сюда мы передаём дефолтное значение.\n\n  reducers: {\n    increment(state, action) {\n      state.count += action.payload;\n    },\n    decrement(state, action) {\n      state.count -= action.payload;\n    },\n    // // Первый редюсер будет вызываться в тот момент, когда мы начинаем подгрузку пользователей.\n    usersFetching(state) {\n      state.isLoading = true;\n    },\n    // Второй редюсер будет вызываться в случае успешной загрузки\n    usersFetchingSuccess(state, action) {\n      state.isLoading = false;\n      state.error = \"\"; // обнуляем ошибку, на случай, если она была\n      state.users = action.payload; // меняем состояние, добавляем массив пользователей.\n    },\n\n    // Третий редюсер будет вызываться в случае загрузки с ошибкой\n    usersFetchingError(state, action) {\n      state.isLoading = false;\n      state.error = action.payload;\n    }\n  }\n});\n\n// После создания слайса, мы можем вытащить из него отдельный редюсер\n// и отдельный экшен-креатер. Например:\n\nexport default userSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","users","isLoading","error","count","userSlice","name","reducers","increment","state","action","payload","decrement","usersFetching","usersFetchingSuccess","usersFetchingError","reducer"],"sources":["C:/Projects Ulbi/redux-toolkit-typescript-3/src/store/reducers/UserSlice.ts"],"sourcesContent":["// В редакс редюсер - это просто по сути чистая функция, которая принимает\r\n// state, action. В зависимости от экшена как-то изменяет state и возвращает\r\n// его нам в обновлённом виде. В редакс-тулкит есть, так называемые, слайсы.\r\n// Это некоторая обёртка над редюсерами, которая добовляет дополнительный\r\n// функционал и упрощает работу.\r\n\r\nimport { IUser } from \"../../models/types\";\r\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\n\r\ninterface UserState {\r\n  users: IUser[];\r\n  isLoading: boolean;\r\n  error: string;\r\n  count: number;\r\n}\r\n\r\n// Создаём объект типа UserState, который ожидаем в качестве загрузки.\r\nconst initialState: UserState = {\r\n  users: [],\r\n  isLoading: false,\r\n  error: \"\",\r\n  count: 0,\r\n};\r\n\r\n// Создаём сам редюсер. Подобные редюсеры в тулкит называются слайсами.\r\n// Создаются они помощью специальной функции createSlice() и принимают параметрами\r\n// объект с опциями.\r\nexport const userSlice = createSlice({\r\n  name: \"user\",\r\n  initialState: initialState, // Сюда мы передаём дефолтное значение.\r\n\r\n  reducers: {\r\n    increment(state, action: PayloadAction<number>) {\r\n      state.count += action.payload;\r\n    },\r\n    decrement(state, action: PayloadAction<number>) {\r\n      state.count -= action.payload;\r\n    },\r\n    // // Первый редюсер будет вызываться в тот момент, когда мы начинаем подгрузку пользователей.\r\n    usersFetching(state) {\r\n      state.isLoading = true;\r\n    },\r\n    // Второй редюсер будет вызываться в случае успешной загрузки\r\n    usersFetchingSuccess(state, action: PayloadAction<IUser[]>) {\r\n      state.isLoading = false;\r\n      state.error = \"\"; // обнуляем ошибку, на случай, если она была\r\n      state.users = action.payload; // меняем состояние, добавляем массив пользователей.\r\n    },\r\n    // Третий редюсер будет вызываться в случае загрузки с ошибкой\r\n    usersFetchingError(state, action: PayloadAction<string>) {\r\n      state.isLoading = false;\r\n      state.error = action.payload;\r\n    },\r\n  },\r\n});\r\n\r\n// После создания слайса, мы можем вытащить из него отдельный редюсер\r\n// и отдельный экшен-креатер. Например:\r\n\r\nexport default userSlice.reducer;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAGA,SAASA,WAAW,QAAuB,kBAAkB;AAS7D;AACA,MAAMC,YAAuB,GAAG;EAC9BC,KAAK,EAAE,EAAE;EACTC,SAAS,EAAE,KAAK;EAChBC,KAAK,EAAE,EAAE;EACTC,KAAK,EAAE;AACT,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAGN,WAAW,CAAC;EACnCO,IAAI,EAAE,MAAM;EACZN,YAAY,EAAEA,YAAY;EAAE;;EAE5BO,QAAQ,EAAE;IACRC,SAASA,CAACC,KAAK,EAAEC,MAA6B,EAAE;MAC9CD,KAAK,CAACL,KAAK,IAAIM,MAAM,CAACC,OAAO;IAC/B,CAAC;IACDC,SAASA,CAACH,KAAK,EAAEC,MAA6B,EAAE;MAC9CD,KAAK,CAACL,KAAK,IAAIM,MAAM,CAACC,OAAO;IAC/B,CAAC;IACD;IACAE,aAAaA,CAACJ,KAAK,EAAE;MACnBA,KAAK,CAACP,SAAS,GAAG,IAAI;IACxB,CAAC;IACD;IACAY,oBAAoBA,CAACL,KAAK,EAAEC,MAA8B,EAAE;MAC1DD,KAAK,CAACP,SAAS,GAAG,KAAK;MACvBO,KAAK,CAACN,KAAK,GAAG,EAAE,CAAC,CAAC;MAClBM,KAAK,CAACR,KAAK,GAAGS,MAAM,CAACC,OAAO,CAAC,CAAC;IAChC,CAAC;;IACD;IACAI,kBAAkBA,CAACN,KAAK,EAAEC,MAA6B,EAAE;MACvDD,KAAK,CAACP,SAAS,GAAG,KAAK;MACvBO,KAAK,CAACN,KAAK,GAAGO,MAAM,CAACC,OAAO;IAC9B;EACF;AACF,CAAC,CAAC;;AAEF;AACA;;AAEA,eAAeN,SAAS,CAACW,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}